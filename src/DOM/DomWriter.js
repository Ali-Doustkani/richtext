import createRenderListManager from './editorSiblings'

/**
 * Renders the model to the editor and creates new elements surround it if needed.
 * It also returns the element that must be focused after rendering.
 * @param {HTMLElement} editor The current editor that user is typing in.
 * @param {object} model The style model generated by Stylist.
 * @returns {HTMLElement} The active element that is specified by the model.
 */
function render(richtext, editor, model) {
  editor.innerHTML = ''
  const manager = createRenderListManager(richtext, editor)
  model.forEach(item =>
    manager.getOrCreateEditor(item).appendChild(children(item))
  )
  generateList(richtext, manager.getRenderList(), manager.getOriginal())
  return manager.getActive()
}

function children(item) {
  let element
  const notParentEffects = (item.effects || []).filter(x => !x.parent)
  if (notParentEffects.length) {
    element = item.text
    notParentEffects.forEach(effect => (element = el(effect).value(element)))
  } else {
    element = el(item.text)
  }
  return element
}

function el(option) {
  if (typeof option === 'string') {
    return document.createTextNode(option)
  }
  const element = document.createElement(option.tag)
  if (option.className) {
    element.setAttribute('class', option.className)
  }
  return {
    value: value => {
      value = typeof value === 'string' ? document.createTextNode(value) : value
      element.appendChild(value)
      return element
    }
  }
}

function generateList(richtext, elements, original) {
  const originalIndex = elements.indexOf(original)
  for (let i = originalIndex; i > 0; i--) {
    richtext.insertBefore(elements[i - 1], elements[i])
  }
  for (let i = originalIndex; i < elements.length - 1; i++) {
    richtext.insertBefore(elements[i + 1], elements[i + 1].nextSibling)
  }
}

export default render
